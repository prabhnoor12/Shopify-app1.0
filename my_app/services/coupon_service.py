import logging
import uuid
from datetime import datetime, timedelta
from typing import Optional, List
from sqlalchemy.orm import Session

from ..models.coupon import Coupon
from ..models.coupon_usage_log import CouponUsageLog
from ..schemas.coupon import CouponCreate, CouponResponse
from ..exceptions import (
    CouponNotFoundError,
    CouponExpiredError,
    CouponAlreadyUsedError,
    InvalidCouponDataError,
    DatabaseException,
    ValidationException,
)

logger = logging.getLogger(__name__)


class CouponService:
    """
    Service class for managing coupon generation, validation, and redemption.
    Provides robust error handling, input validation, and atomic operations.
    """

    def __init__(self, db: Session):
        self.db = db

    def _get_coupon_status(self, coupon: Coupon) -> str:
        """
        Determines the current status of a coupon.
        """
        now = datetime.utcnow()
        if now < coupon.start_date:
            return "scheduled"
        if now > coupon.end_date:
            return "expired"
        if coupon.usage_limit is not None and coupon.used_count >= coupon.usage_limit:
            return "used_up"
        # Add logic for 'disabled' if a status field is added to the model
        return "active"

    def generate_coupon(self, coupon_data: CouponCreate) -> CouponResponse:
        """
        Generates a unique coupon code with specified discount and expiry.

        Args:
            coupon_data: Pydantic model containing coupon details.

        Returns:
            A CouponResponse object representing the newly generated coupon.

        Raises:
            InvalidCouponDataError: If the provided coupon data is invalid.
            DatabaseException: If there's an issue during database interaction.
        """
        try:
            if coupon_data.discount_type not in ["percentage", "flat"]:
                raise InvalidCouponDataError(
                    "discount_type must be 'percentage' or 'flat'."
                )
            if coupon_data.discount_type == "percentage" and not (
                0 < coupon_data.value <= 100
            ):
                raise InvalidCouponDataError(
                    "Percentage discount value must be between 0 and 100."
                )
            if coupon_data.min_spend is not None and coupon_data.min_spend < 0:
                raise InvalidCouponDataError("min_spend cannot be negative.")
            if coupon_data.max_discount is not None and coupon_data.max_discount < 0:
                raise InvalidCouponDataError("max_discount cannot be negative.")

            coupon_code = str(uuid.uuid4()).replace("-", "")[:10].upper()
            end_date = datetime.utcnow() + timedelta(days=coupon_data.expires_in_days)

            coupon = Coupon(
                code=coupon_code,
                inviter_user_id=coupon_data.inviter_user_id,
                discount_type=coupon_data.discount_type,
                value=coupon_data.value,
                min_spend=coupon_data.min_spend,
                max_discount=coupon_data.max_discount,
                start_date=datetime.utcnow(),  # Coupons are active immediately unless specified
                end_date=end_date,
                usage_limit=coupon_data.usage_limit,
                per_user_limit=coupon_data.per_user_limit,
                used_count=0,
            )
            self.db.add(coupon)
            self.db.commit()
            self.db.refresh(coupon)
            logger.info(
                f"Coupon {coupon.code} generated by user {coupon.inviter_user_id}."
            )
            response = CouponResponse.from_orm(coupon)
            response.status = self._get_coupon_status(coupon)
            return response
        except InvalidCouponDataError as e:
            self.db.rollback()
            raise e
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error generating coupon: {e}", exc_info=True)
            raise DatabaseException(f"Failed to generate coupon: {e}") from e

    def validate_coupon(
        self,
        code: str,
        user_id: Optional[int] = None,
        current_spend: Optional[float] = None,
    ) -> CouponResponse:
        """
        Validates a coupon code against various rules.

        Args:
            code: The coupon code to validate.
            user_id: Optional ID of the user attempting to use the coupon (for per-user limits).
            current_spend: Optional current spend amount (for minimum spend check).

        Returns:
            A CouponResponse object if the coupon is valid.

        Raises:
            CouponNotFoundError: If the coupon does not exist.
            CouponExpiredError: If the coupon has expired or is not yet active.
            CouponAlreadyUsedError: If the coupon has reached its total usage limit or per-user limit.
            ValidationException: If minimum spend is not met.
            DatabaseException: If there's an issue during database interaction.
        """
        try:
            coupon = self.db.query(Coupon).filter(Coupon.code == code).first()
            if not coupon:
                logger.warning(f"Validation failed: Coupon {code} not found.")
                raise CouponNotFoundError(f"Coupon {code} not found.")

            now = datetime.utcnow()
            if now < coupon.start_date or now > coupon.end_date:
                logger.warning(
                    f"Validation failed: Coupon {code} is not active or expired."
                )
                raise CouponExpiredError(f"Coupon {code} is not active or has expired.")

            if (
                coupon.usage_limit is not None
                and coupon.used_count >= coupon.usage_limit
            ):
                logger.warning(
                    f"Validation failed: Coupon {code} has reached its total usage limit."
                )
                raise CouponAlreadyUsedError(
                    f"Coupon {code} has reached its total usage limit."
                )

            if user_id is not None and coupon.per_user_limit is not None:
                user_usage_count = (
                    self.db.query(CouponUsageLog)
                    .filter(
                        CouponUsageLog.coupon_id == coupon.id,
                        CouponUsageLog.user_id == user_id,
                    )
                    .count()
                )
                if user_usage_count >= coupon.per_user_limit:
                    logger.warning(
                        f"Validation failed: Coupon {code} has reached its per-user limit for user {user_id}."
                    )
                    raise CouponAlreadyUsedError(
                        f"Coupon {code} has reached its per-user limit for user {user_id}."
                    )

            if (
                coupon.min_spend is not None
                and current_spend is not None
                and current_spend < coupon.min_spend
            ):
                logger.warning(
                    f"Validation failed: Coupon {code} requires a minimum spend of {coupon.min_spend}, but current spend is {current_spend}."
                )
                raise ValidationException(
                    f"Minimum spend of {coupon.min_spend} not met."
                )

            logger.info(f"Coupon {code} validated successfully.")
            response = CouponResponse.from_orm(coupon)
            response.status = self._get_coupon_status(coupon)
            return response
        except (
            CouponNotFoundError,
            CouponExpiredError,
            CouponAlreadyUsedError,
            ValidationException,
        ) as e:
            raise e
        except Exception as e:
            logger.error(f"Error validating coupon {code}: {e}", exc_info=True)
            raise DatabaseException(f"Failed to validate coupon {code}: {e}") from e

    def redeem_coupon(
        self, code: str, user_id: int, order_id: Optional[int] = None
    ) -> CouponResponse:
        """
        Redeems a coupon for a user, marking it as used and logging the usage.
        Ensures atomic update to prevent race conditions.

        Args:
            code: The coupon code to redeem.
            user_id: The ID of the user redeeming the coupon.
            order_id: Optional ID of the order associated with the redemption.

        Returns:
            A CouponResponse object representing the redeemed coupon.

        Raises:
            CouponNotFoundError: If the coupon does not exist.
            CouponExpiredError: If the coupon has expired or is not yet active.
            CouponAlreadyUsedError: If the coupon has reached its total usage limit or per-user limit.
            DatabaseException: If there's an issue during database interaction.
        """
        try:
            # First, perform all validations
            self.validate_coupon(
                code, user_id
            )  # This will raise appropriate exceptions if invalid

            coupon = self.db.query(Coupon).filter(Coupon.code == code).first()
            if (
                not coupon
            ):  # Should not happen if validate_coupon passed, but for type hinting
                raise CouponNotFoundError(f"Coupon {code} not found after validation.")

            # Atomically update used_count and create usage log
            # This requires a transaction to ensure both operations succeed or fail together
            with self.db.begin_nested():  # Use nested transaction for atomicity
                # Increment used_count on the Coupon
                updated_count_coupon = (
                    self.db.query(Coupon)
                    .filter(
                        Coupon.id == coupon.id,
                        (Coupon.usage_limit == cond is None)
                        | (Coupon.used_count < Coupon.usage_limit),
                    )
                    .update(
                        {Coupon.used_count: Coupon.used_count + 1},
                        synchronize_session=False,
                    )
                )

                if updated_count_coupon == 0:
                    # This means the usage limit was hit between validation and update
                    raise CouponAlreadyUsedError(
                        f"Coupon {code} usage limit reached during redemption attempt."
                    )

                # Create a new CouponUsageLog entry
                usage_log = CouponUsageLog(
                    coupon_id=coupon.id,
                    user_id=user_id,
                    order_id=order_id,
                    used_at=datetime.utcnow(),
                )
                self.db.add(usage_log)
                self.db.flush()  # Flush to ensure usage_log.id is populated if needed later

            self.db.commit()  # Commit the nested transaction

            self.db.refresh(coupon)  # Refresh coupon object to get updated used_count
            logger.info(
                f"Coupon {code} redeemed by user {user_id} for order {order_id or 'N/A'}."
            )
            response = CouponResponse.from_orm(coupon)
            response.status = self._get_coupon_status(coupon)
            return response
        except (
            CouponNotFoundError,
            CouponExpiredError,
            CouponAlreadyUsedError,
            ValidationException,
        ) as e:
            self.db.rollback()
            raise e
        except Exception as e:
            self.db.rollback()
            logger.error(
                f"Error redeeming coupon {code} for user {user_id}: {e}", exc_info=True
            )
            raise DatabaseException(f"Failed to redeem coupon {code}: {e}") from e

    def get_coupons_by_user(self, user_id: int) -> List[CouponResponse]:
        """
        Lists all coupons generated by a specific user.

        Args:
            user_id: The ID of the user who generated the coupons.

        Returns:
            A list of CouponResponse objects.

        Raises:
            DatabaseException: If there's an issue during database interaction.
        """
        try:
            coupons = (
                self.db.query(Coupon).filter(Coupon.inviter_user_id == user_id).all()
            )
            logger.info(f"Fetched {len(coupons)} coupons for user {user_id}.")
            response_list = []
            for coupon in coupons:
                response = CouponResponse.from_orm(coupon)
                response.status = self._get_coupon_status(coupon)
                response_list.append(response)
            return response_list
        except Exception as e:
            logger.error(
                f"Error fetching coupons for user {user_id}: {e}", exc_info=True
            )
            raise DatabaseException(
                f"Failed to fetch coupons for user {user_id}: {e}"
            ) from e
